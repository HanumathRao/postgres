#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage: scripts/generate-leftdeep-repro-sql.sh [QUERY_FILE] [OUTPUT_SQL] [ROW_COUNT]

Defaults:
  QUERY_FILE  /tmp/leftdeep_proof.sql
  OUTPUT_SQL  /tmp/leftdeep_repro.sql
  ROW_COUNT   60000

Generates one self-contained SQL script with:
  - schema + table creation
  - deterministic data population
  - ANALYZE
  - EXPLAIN blocks for enable_left_deep_join off/on (PostgreSQL patched build)

The output is designed to be mostly portable to PostgreSQL-compatible systems.
EOF
}

if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  usage
  exit 0
fi

QUERY_FILE="${1:-/tmp/leftdeep_proof.sql}"
OUTPUT_SQL="${2:-/tmp/leftdeep_repro.sql}"
ROW_COUNT="${3:-60000}"

if [[ ! -f "${QUERY_FILE}" ]]; then
  echo "Query file not found: ${QUERY_FILE}" >&2
  exit 1
fi

if ! [[ "${ROW_COUNT}" =~ ^[0-9]+$ ]] || [[ "${ROW_COUNT}" -lt 1000 ]]; then
  echo "ROW_COUNT must be an integer >= 1000, got: ${ROW_COUNT}" >&2
  exit 2
fi

# Keep query formatting, trim trailing semicolon/whitespace.
QUERY="$(perl -0777 -ne '
  $_ =~ s/^\s+//;
  $_ =~ s/\s+$//;
  $_ =~ s/;\s*$//;
  print $_;
' "${QUERY_FILE}")"

if [[ -z "${QUERY}" ]]; then
  echo "Query file is empty after trimming: ${QUERY_FILE}" >&2
  exit 1
fi

SUPPLIER_COUNT=$(( ROW_COUNT / 8 ))
CUSTOMER_COUNT=$(( ROW_COUNT / 2 ))
PART_COUNT=$(( ROW_COUNT / 3 ))
if (( SUPPLIER_COUNT < 1000 )); then SUPPLIER_COUNT=1000; fi
if (( CUSTOMER_COUNT < 5000 )); then CUSTOMER_COUNT=5000; fi
if (( PART_COUNT < 3000 )); then PART_COUNT=3000; fi

cat > "${OUTPUT_SQL}" <<EOF
-- Auto-generated by scripts/generate-leftdeep-repro-sql.sh
-- Source query: ${QUERY_FILE}
-- Row count: ${ROW_COUNT}
--
-- Notes:
-- 1) This script is self-contained: creates schema, loads data, analyzes.
-- 2) The \`enable_left_deep_join\` GUC exists only in your patched PostgreSQL.
--    For other engines, run the plain EXPLAIN blocks near the end.

DROP SCHEMA IF EXISTS tpch_like CASCADE;
CREATE SCHEMA tpch_like;

CREATE TABLE tpch_like._nums (n int);
INSERT INTO tpch_like._nums
WITH RECURSIVE seq(n) AS (
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM seq WHERE n < ${ROW_COUNT}
)
SELECT n FROM seq;

CREATE TABLE tpch_like.region (
  r_regionkey int PRIMARY KEY,
  r_name varchar(16)
);

CREATE TABLE tpch_like.nation (
  n_nationkey int PRIMARY KEY,
  n_regionkey int NOT NULL,
  n_name varchar(32)
);

CREATE TABLE tpch_like.supplier (
  s_suppkey int PRIMARY KEY,
  s_nationkey int NOT NULL
);

CREATE TABLE tpch_like.customer (
  c_custkey int PRIMARY KEY,
  c_nationkey int NOT NULL
);

CREATE TABLE tpch_like.part (
  p_partkey int PRIMARY KEY,
  p_brand varchar(16)
);

CREATE TABLE tpch_like.partsupp (
  ps_partkey int NOT NULL,
  ps_suppkey int NOT NULL,
  ps_supplycost numeric(12,2)
);

CREATE TABLE tpch_like.orders (
  o_orderkey int PRIMARY KEY,
  o_custkey int NOT NULL,
  o_orderdate date
);

CREATE TABLE tpch_like.lineitem (
  l_orderkey int NOT NULL,
  l_partkey int NOT NULL,
  l_suppkey int NOT NULL,
  l_quantity int,
  l_extendedprice numeric(12,2),
  l_discount numeric(6,4),
  l_shipdate date
);

INSERT INTO tpch_like.region VALUES
  (0, 'R0'), (1, 'R1'), (2, 'R2'), (3, 'R3'), (4, 'R4');

INSERT INTO tpch_like.nation
SELECT n - 1,
       (n - 1) % 5,
       'N' || (n - 1)::varchar
FROM tpch_like._nums
WHERE n <= 25;

INSERT INTO tpch_like.supplier
SELECT n,
       n % 25
FROM tpch_like._nums
WHERE n <= ${SUPPLIER_COUNT};

INSERT INTO tpch_like.customer
SELECT n,
       n % 25
FROM tpch_like._nums
WHERE n <= ${CUSTOMER_COUNT};

INSERT INTO tpch_like.part
SELECT n,
       'B' || (n % 40)::varchar
FROM tpch_like._nums
WHERE n <= ${PART_COUNT};

INSERT INTO tpch_like.partsupp
SELECT p.p_partkey,
       ((p.p_partkey * 37 + f.n * 11) % ${SUPPLIER_COUNT}) + 1,
       ((p.p_partkey % 100) + 1)::numeric(12,2)
FROM tpch_like.part p
CROSS JOIN (SELECT 1 AS n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4) f;

INSERT INTO tpch_like.orders
SELECT n,
       ((n * 13) % ${CUSTOMER_COUNT}) + 1,
       DATE '1993-01-01' + ((n * 17) % 2555)
FROM tpch_like._nums
WHERE n <= ${ROW_COUNT};

INSERT INTO tpch_like.lineitem
SELECT o.o_orderkey,
       ((o.o_orderkey * f.n * 7) % ${PART_COUNT}) + 1,
       ((o.o_orderkey * f.n * 3) % ${SUPPLIER_COUNT}) + 1,
       ((o.o_orderkey + f.n) % 50) + 1,
       ((o.o_orderkey % 1000) + f.n * 5)::numeric(12,2),
       ((f.n % 10) / 100.0)::numeric(6,4),
       o.o_orderdate + ((f.n * 5) % 120)
FROM tpch_like.orders o
JOIN (SELECT 1 AS n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4) f ON true;

ANALYZE tpch_like.region;
ANALYZE tpch_like.nation;
ANALYZE tpch_like.supplier;
ANALYZE tpch_like.customer;
ANALYZE tpch_like.part;
ANALYZE tpch_like.partsupp;
ANALYZE tpch_like.orders;
ANALYZE tpch_like.lineitem;

-- Repro query from proof file:
-- ${QUERY_FILE}

-- Optional sanity:
SELECT COUNT(*) AS orders_count FROM tpch_like.orders;
SELECT COUNT(*) AS lineitem_count FROM tpch_like.lineitem;

-- Patched PostgreSQL comparison:
-- (If your engine does not support these settings, skip this block.)
SET geqo = off;
SET join_collapse_limit = 20;
SET from_collapse_limit = 20;
SET enable_nestloop = off;

SET enable_left_deep_join = off;
EXPLAIN (FORMAT JSON)
${QUERY};

SET enable_left_deep_join = on;
EXPLAIN (FORMAT JSON)
${QUERY};

-- Portable fallback (works on most PostgreSQL-like systems):
EXPLAIN
${QUERY};

SELECT
(${QUERY}) AS query_result;
EOF

echo "Wrote: ${OUTPUT_SQL}"
