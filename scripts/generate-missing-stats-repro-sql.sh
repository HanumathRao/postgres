#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage: scripts/generate-missing-stats-repro-sql.sh [QUERY_FILE] [OUTPUT_SQL] [ROW_COUNT] [MISSING_TABLE]

Defaults:
  QUERY_FILE    /tmp/missing_stats_proof.sql
  OUTPUT_SQL    /tmp/missing_stats_repro.sql
  ROW_COUNT     20000
  MISSING_TABLE lineitem

Generates one self-contained SQL script that:
  1) creates and populates a TPCH-like schema (msproof_tpch)
  2) ANALYZEs all tables except MISSING_TABLE
  3) runs EXPLAIN (FORMAT JSON) for:
       - enable_left_deep_join_on_missing_stats=off
       - enable_left_deep_join_on_missing_stats=on

The output is targeted at PostgreSQL-compatible systems.
EOF
}

if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  usage
  exit 0
fi

QUERY_FILE="${1:-/tmp/missing_stats_proof.sql}"
OUTPUT_SQL="${2:-/tmp/missing_stats_repro.sql}"
ROW_COUNT="${3:-20000}"
MISSING_TABLE="${4:-lineitem}"

if [[ ! -f "${QUERY_FILE}" ]]; then
  echo "Query file not found: ${QUERY_FILE}" >&2
  exit 1
fi

if ! [[ "${ROW_COUNT}" =~ ^[0-9]+$ ]] || (( ROW_COUNT < 1000 )); then
  echo "ROW_COUNT must be an integer >= 1000, got: ${ROW_COUNT}" >&2
  exit 2
fi

case "${MISSING_TABLE}" in
  region|nation|supplier|customer|part|partsupp|orders|lineitem) ;;
  *)
    echo "MISSING_TABLE must be one of: region,nation,supplier,customer,part,partsupp,orders,lineitem" >&2
    echo "Got: ${MISSING_TABLE}" >&2
    exit 2
    ;;
esac

# Keep query formatting, trim trailing semicolon/whitespace.
QUERY="$(perl -0777 -ne '
  $_ =~ s/^\s+//;
  $_ =~ s/\s+$//;
  $_ =~ s/;\s*$//;
  print $_;
' "${QUERY_FILE}")"

if [[ -z "${QUERY}" ]]; then
  echo "Query file is empty after trimming: ${QUERY_FILE}" >&2
  exit 1
fi

SUPPLIER_COUNT=$(( ROW_COUNT / 8 ))
CUSTOMER_COUNT=$(( ROW_COUNT / 2 ))
PART_COUNT=$(( ROW_COUNT / 3 ))
ORDER_COUNT=${ROW_COUNT}
if (( SUPPLIER_COUNT < 1000 )); then SUPPLIER_COUNT=1000; fi
if (( CUSTOMER_COUNT < 5000 )); then CUSTOMER_COUNT=5000; fi
if (( PART_COUNT < 3000 )); then PART_COUNT=3000; fi
if (( ORDER_COUNT < 30000 )); then ORDER_COUNT=30000; fi

cat > "${OUTPUT_SQL}" <<EOF
-- Auto-generated by scripts/generate-missing-stats-repro-sql.sh
-- Source query: ${QUERY_FILE}
-- Row count: ${ROW_COUNT}
-- Missing-stats table (left unanalyzed): ${MISSING_TABLE}
--
-- This script demonstrates the effect of:
--   enable_left_deep_join_on_missing_stats

DROP SCHEMA IF EXISTS msproof_tpch CASCADE;
CREATE SCHEMA msproof_tpch;

CREATE TABLE msproof_tpch.region (
  r_regionkey int PRIMARY KEY,
  r_name varchar(16)
);

CREATE TABLE msproof_tpch.nation (
  n_nationkey int PRIMARY KEY,
  n_regionkey int NOT NULL,
  n_name varchar(32)
);

CREATE TABLE msproof_tpch.supplier (
  s_suppkey int PRIMARY KEY,
  s_nationkey int NOT NULL
);

CREATE TABLE msproof_tpch.customer (
  c_custkey int PRIMARY KEY,
  c_nationkey int NOT NULL
);

CREATE TABLE msproof_tpch.part (
  p_partkey int PRIMARY KEY,
  p_brand varchar(16)
);

CREATE TABLE msproof_tpch.partsupp (
  ps_partkey int NOT NULL,
  ps_suppkey int NOT NULL,
  ps_supplycost numeric(12,2)
);

CREATE TABLE msproof_tpch.orders (
  o_orderkey int PRIMARY KEY,
  o_custkey int NOT NULL,
  o_orderdate date
);

CREATE TABLE msproof_tpch.lineitem (
  l_orderkey int NOT NULL,
  l_partkey int NOT NULL,
  l_suppkey int NOT NULL,
  l_quantity int,
  l_extendedprice numeric(12,2),
  l_discount numeric(6,4),
  l_shipdate date
);

INSERT INTO msproof_tpch.region VALUES
  (0, 'R0'), (1, 'R1'), (2, 'R2'), (3, 'R3'), (4, 'R4');

INSERT INTO msproof_tpch.nation
SELECT i, (i % 5), 'N' || i::varchar
FROM generate_series(0, 24) i;

INSERT INTO msproof_tpch.supplier
SELECT i, (i % 25)
FROM generate_series(1, ${SUPPLIER_COUNT}) i;

INSERT INTO msproof_tpch.customer
SELECT i, (i % 25)
FROM generate_series(1, ${CUSTOMER_COUNT}) i;

INSERT INTO msproof_tpch.part
SELECT i, 'B' || (i % 40)::varchar
FROM generate_series(1, ${PART_COUNT}) i;

INSERT INTO msproof_tpch.partsupp
SELECT p.p_partkey,
       ((p.p_partkey * 37 + f.n * 11) % ${SUPPLIER_COUNT}) + 1,
       ((p.p_partkey % 100) + 1)::numeric(12,2)
FROM msproof_tpch.part p
JOIN (SELECT 1 AS n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4) f ON true;

INSERT INTO msproof_tpch.orders
SELECT i,
       ((i * 13) % ${CUSTOMER_COUNT}) + 1,
       DATE '1993-01-01' + ((i * 17) % 2555)
FROM generate_series(1, ${ORDER_COUNT}) i;

INSERT INTO msproof_tpch.lineitem
SELECT o.o_orderkey,
       ((o.o_orderkey * f.n * 7) % ${PART_COUNT}) + 1,
       ((o.o_orderkey * f.n * 3) % ${SUPPLIER_COUNT}) + 1,
       ((o.o_orderkey + f.n) % 50) + 1,
       ((o.o_orderkey % 1000) + f.n * 5)::numeric(12,2),
       ((f.n % 10) / 100.0)::numeric(6,4),
       o.o_orderdate + ((f.n * 5) % 120)
FROM msproof_tpch.orders o
JOIN (SELECT 1 AS n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4) f ON true;

-- Analyze everything except the chosen missing-stats table.
ALTER TABLE msproof_tpch.${MISSING_TABLE}
  SET (autovacuum_enabled = off, toast.autovacuum_enabled = off);
EOF

for t in region nation supplier customer part partsupp orders lineitem; do
  if [[ "${t}" == "${MISSING_TABLE}" ]]; then
    continue
  fi
  echo "ANALYZE msproof_tpch.${t};" >> "${OUTPUT_SQL}"
done

cat >> "${OUTPUT_SQL}" <<EOF

-- Show reltuples: missing table should remain at -1 (or otherwise clearly stale).
SELECT relname, reltuples
FROM pg_class
WHERE oid IN (
  'msproof_tpch.region'::regclass,
  'msproof_tpch.nation'::regclass,
  'msproof_tpch.supplier'::regclass,
  'msproof_tpch.customer'::regclass,
  'msproof_tpch.part'::regclass,
  'msproof_tpch.partsupp'::regclass,
  'msproof_tpch.orders'::regclass,
  'msproof_tpch.lineitem'::regclass
)
ORDER BY relname;

-- Repro query from proof file:
-- ${QUERY_FILE}

SET jit = off;
SET geqo = off;
SET join_collapse_limit = 20;
SET from_collapse_limit = 20;
SET enable_left_deep_join = off;

SET enable_left_deep_join_on_missing_stats = off;
EXPLAIN (FORMAT JSON)
${QUERY};

SET enable_left_deep_join_on_missing_stats = on;
EXPLAIN (FORMAT JSON)
${QUERY};
EOF

echo "Wrote: ${OUTPUT_SQL}"
